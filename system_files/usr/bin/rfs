#!/usr/bin/env python

from __future__ import annotations

import argparse
import inspect
import ipaddress
import json
import os
import pathlib
import getpass
import random
import subprocess
import sys
import tempfile
import tomllib
import re
import glob
import shutil
from pwd import getpwnam
from grp import getgrnam


class ptc:  # print text colours

    # Reset
    Color_Off = "\033[0m"  # Text Reset

    # Regular Colors
    Black = "\033[0;30m"  # Black
    Red = "\033[0;31m"  # Red
    Green = "\033[0;32m"  # Green
    Yellow = "\033[0;33m"  # Yellow
    Blue = "\033[0;34m"  # Blue
    Purple = "\033[0;35m"  # Purple
    Cyan = "\033[0;36m"  # Cyan
    White = "\033[0;37m"  # White

    # Bold
    BBlack = "\033[1;30m"  # Black
    BRed = "\033[1;31m"  # Red
    BGreen = "\033[1;32m"  # Green
    BYellow = "\033[1;33m"  # Yellow
    BBlue = "\033[1;34m"  # Blue
    BPurple = "\033[1;35m"  # Purple
    BCyan = "\033[1;36m"  # Cyan
    BWhite = "\033[1;37m"  # White

    # Underline
    UBlack = "\033[4;30m"  # Black
    URed = "\033[4;31m"  # Red
    UGreen = "\033[4;32m"  # Green
    UYellow = "\033[4;33m"  # Yellow
    UBlue = "\033[4;34m"  # Blue
    UPurple = "\033[4;35m"  # Purple
    UCyan = "\033[4;36m"  # Cyan
    UWhite = "\033[4;37m"  # White

    # Background
    On_Black = "\033[40m"  # Black
    On_Red = "\033[41m"  # Red
    On_Green = "\033[42m"  # Green
    On_Yellow = "\033[43m"  # Yellow
    On_Blue = "\033[44m"  # Blue
    On_Purple = "\033[45m"  # Purple
    On_Cyan = "\033[46m"  # Cyan
    On_White = "\033[47m"  # White

    # High Intensity
    IBlack = "\033[0;90m"  # Black
    IRed = "\033[0;91m"  # Red
    IGreen = "\033[0;92m"  # Green
    IYellow = "\033[0;93m"  # Yellow
    IBlue = "\033[0;94m"  # Blue
    IPurple = "\033[0;95m"  # Purple
    ICyan = "\033[0;96m"  # Cyan
    IWhite = "\033[0;97m"  # White

    # Bold High Intensity
    BIBlack = "\033[1;90m"  # Black
    BIRed = "\033[1;91m"  # Red
    BIGreen = "\033[1;92m"  # Green
    BIYellow = "\033[1;93m"  # Yellow
    BIBlue = "\033[1;94m"  # Blue
    BIPurple = "\033[1;95m"  # Purple
    BICyan = "\033[1;96m"  # Cyan
    BIWhite = "\033[1;97m"  # White

    # High Intensity backgrounds
    On_IBlack = "\033[0;100m"  # Black
    On_IRed = "\033[0;101m"  # Red
    On_IGreen = "\033[0;102m"  # Green
    On_IYellow = "\033[0;103m"  # Yellow
    On_IBlue = "\033[0;104m"  # Blue
    On_IPurple = "\033[0;105m"  # Purple
    On_ICyan = "\033[0;106m"  # Cyan
    On_IWhite = "\033[0;107m"  # White


# ------------------------------------------------------------------------------


def unit_tests(tests: list[list]) -> None:

    results = []

    t_result_pending = f"{ptc.Yellow}[PENDING]{ptc.Color_Off}"
    t_result_pass = f"{ptc.Green}[PASS]{ptc.Color_Off}"
    t_result_fail = f"{ptc.Red}[FAIL]{ptc.Color_Off}"

    for t in tests:
        t_tested_function = f"{t[0]}"
        t_input_data = f"'{t[1]}'"
        t_expected_outcome = f"{t[2]}"

        t_output = [
            t_result_pending,
            t_tested_function,
            t_input_data,
            t_expected_outcome,
        ]

        try:
            if t[2]:
                assert globals()[f"{t[0]}"](t[1])
            else:
                assert not valid_ip(t[1])
            t_output[0] = t_result_pass
            # print(f'{ptc.Green}[PASS]{ptc.Color_Off} {t[0]}("{t[1]}") == {t[2]}')
        except AssertionError as e:
            t_output[0] = t_result_fail
            # print(f'{ptc.Red}[FAIL]{ptc.Color_Off} {t[0]}("{t[1]}") == {t[2]}')

        results.append(t_output)

    print_in_table_format(results)


def exec_cmd(*cmd: str, fail_action="return") -> tuple[bool, str]:
    try:
        try:
            result = subprocess.run(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,  # combine both streams into one
                shell=True,
                text=True,
                check=True,
            )
            return True, result.stdout
        except subprocess.CalledProcessError as e:
            if fail_action == "return":
                return False, e.stdout
            else:
                sys.exit(1)
    except OSError as e:
        if fail_action == "return":
            return False, str(sys.stderr)
        else:
            sys.exit(1)


def valid_ip(ip_str: str) -> bool:
    """
    Validate an IPv4 or IPv6
    https://sqlpey.com/python/top-5-ways-to-validate-ip-addresses-in-python/

    Args:
        ip_str (str): the IP string

    Returns:
        bool: true or false depending on whether it is valid or not
    """
    try:
        ipaddress.ip_address(ip_str)
        return True
    except ValueError:
        return False


def valid_fqdn(hostname: str) -> bool:

    if not 1 < len(hostname) < 253:
        return False

    # Remove trailing dot
    if hostname[-1] == ".":
        hostname = hostname[0:-1]

    #  Split hostname into list of DNS labels
    labels = hostname.split(".")

    #  Define pattern of DNS label
    #  Can begin and end with a number or letter only
    #  Can contain hyphens, a-z, A-Z, 0-9
    #  1 - 63 chars allowed
    fqdn = re.compile(r"^[a-z0-9]([a-z-0-9-]{0,61}[a-z0-9])?$", re.IGNORECASE)

    # Check that all labels match that pattern.
    return all(fqdn.match(label) for label in labels)


# ------------------------------------------------------------------------------


def check_progs_installed(*names, fail_action="return") -> bool | None:
    """Check whether 'names' are on PATH and marked as executable."""

    all_present = True

    for n in names:
        if shutil.which(n) is None:
            print(f"{ptc.Red}Program not available:{ptc.Color_Off} {n}")
            all_present = False

    if fail_action == "return":
        return all_present
    elif not all_present:
        sys.exit(1)


def print_in_table_format(data, padding=0):
    def get_fmt(data):
        fmt = ""
        for column, row in enumerate(data[0]):
            fmt += "{{!s:<{}}} ".format(
                max(len(str(row[column])) for row in data) + padding
            )
        return fmt

    fmt = get_fmt(data)
    for row in data:
        print(fmt.format(*row))


def print_separator(sequence):
    print(f"{str(sequence)}" * os.get_terminal_size().columns)


def print_info(msg):
    print(f"{ptc.Blue}[INFO]{ptc.Color_Off} {msg}")


def print_error(msg):
    print(f"{ptc.Red}[ERROR]{ptc.Color_Off} {msg}")


# ------------------------------------------------------------------------------


def select_from_list(input_message: str, options: list) -> str:

    input_message = f"{input_message}:\n"
    for index, item in enumerate(options):
        input_message += f"{index + 1}) {item}\n"
    input_message += "Your choice (enter number 1-{}): ".format(len(options))

    user_input_num = ""
    selected_option = None

    # Keep asking until a valid number is entered
    valid_numbers = [
        str(i) for i in range(1, len(options) + 1)
    ]  # Create ['1', '2', '3', '4']

    while user_input_num not in valid_numbers:
        user_input_num = input(input_message)
        if user_input_num not in valid_numbers:
            print(
                f"Invalid input. Please enter a number between 1 and {len(options)}.\n"
            )

    # Convert valid input string ('1', '2', etc.) to index (0, 1, etc.)
    selected_index = int(user_input_num) - 1
    selected_option = options[selected_index]

    return selected_option


# ------------------------------------------------------------------------------


def delete_rfs_files(
    credentials_direcrory: str,
    execstart_script_direcrory: str,
    server_name: str,
    share_name: str,
    share_mount_under: str,
) -> None:

    mountpoint = str(
        f"{pathlib.Path( f"{share_mount_under}" ).expanduser().resolve()}/{server_name}/{share_name}"
    )
    systemd_name = str(mountpoint).replace("/", "-").replace("-", "", 1)

    creds_dir = str(pathlib.Path(f"{credentials_direcrory}").expanduser().resolve())
    creds_file = str(
        pathlib.Path(f"{creds_dir}/{systemd_name}.creds").expanduser().resolve()
    )

    print(f"{ptc.Blue}[INFO]{ptc.Color_Off} Disabling & removing files...")

    if exec_cmd(
        f"sudo systemctl disable --now {systemd_name}.timer",
        fail_action="exit",
    ):
        print(f"{ptc.Blue}[INFO]{ptc.Color_Off} Disabled {systemd_name}.timer")
    if exec_cmd(
        f"sudo systemctl stop {systemd_name}.service",
        fail_action="exit",
    ):
        print(f"{ptc.Blue}[INFO]{ptc.Color_Off} Stopped {systemd_name}.service")
    if exec_cmd(
        f"sudo systemctl stop {systemd_name}.automount",
        fail_action="exit",
    ):
        print(f"{ptc.Blue}[INFO]{ptc.Color_Off} Stopped {systemd_name}.automount")
    if exec_cmd(
        f"sudo systemctl stop {systemd_name}.mount",
        fail_action="exit",
    ):
        print(f"{ptc.Blue}[INFO]{ptc.Color_Off} Stopped {systemd_name}.mount")

    if os.path.isfile(f"/var/lib/{systemd_name}.env") and exec_cmd(
        f"sudo rm -vf /var/lib/{systemd_name}.env", fail_action="exit"
    ):
        print(f"{ptc.Blue}[INFO]{ptc.Color_Off} Removed /var/lib/{systemd_name}.env")
    if exec_cmd(
        f"sudo rm -vf {execstart_script_direcrory}/{systemd_name}.sh",
        fail_action="exit",
    ):
        print(
            f"{ptc.Blue}[INFO]{ptc.Color_Off} Removed {execstart_script_direcrory}/{systemd_name}.sh"
        )
    if exec_cmd(
        f'rm -vf "{creds_file}"',
        fail_action="exit",
    ):
        print(f"{ptc.Blue}[INFO]{ptc.Color_Off} Removed {creds_file}")
    if exec_cmd(
        f"sudo rm -vf /etc/systemd/system/{systemd_name}.*",
        fail_action="exit",
    ):
        print(
            f"{ptc.Blue}[INFO]{ptc.Color_Off} Removed /etc/systemd/system/{systemd_name}.*"
        )
    if exec_cmd(
        f"sudo rm -v /etc/systemd/journald@{systemd_name}.conf",
        fail_action="exit",
    ):
        print(
            f"{ptc.Blue}[INFO]{ptc.Color_Off} Removed /etc/systemd/journald@{systemd_name}.conf"
        )

    if exec_cmd(
        f"sudo systemctl daemon-reload",
        fail_action="exit",
    ):
        print(f"{ptc.Blue}[INFO]{ptc.Color_Off} Completed systemctl daemon-reload")

    if os.path.isfile(f"/var/lib/{systemd_name}.rfs") and exec_cmd(
        f"sudo rm -v /var/lib/{systemd_name}.rfs",
        fail_action="exit",
    ):
        print(
            f"{ptc.Blue}[INFO]{ptc.Color_Off} Removed registry file /var/lib/{systemd_name}.rfs"
        )


def generate_rfs_files(
    user_uid: int,
    user_gid: int,
    credentials_direcrory: str,
    execstart_script_direcrory: str,
    server_name: str,
    server_addresses: list,
    share_name: str,
    share_mount_under: str,
    share_username: str,
    share_password: str,
    share_domain: str,
    simulate: bool,
) -> None:

    for addr in server_addresses:
        if not valid_ip(addr) and not valid_fqdn(addr):
            raise ValueError(f"Error - Invalid server address: {addr}")

    server_addresses_oneliner = " ".join(server_addresses)

    mountpoint = str(
        f"{pathlib.Path( f"{share_mount_under}" ).expanduser().resolve()}/{server_name}/{share_name}"
    )
    systemd_name = str(mountpoint).replace("/", "-").replace("-", "", 1)

    creds_dir = str(pathlib.Path(f"{credentials_direcrory}").expanduser().resolve())
    creds_file = str(
        pathlib.Path(f"{creds_dir}/{systemd_name}.creds").expanduser().resolve()
    )

    service_script = inspect.cleandoc(
        f"""\
            #!/usr/bin/env bash
            set -euo pipefail

            executor=\"${{0##*/}}\"

            # ------------------------------------------------------------------------------

            declare -a required_cmds=( \"nc\" )

            fail=false
            for rc in \"${{required_cmds[@]}}\"; do
                if ! command -v \"${{rc}}\" &> /dev/null ; then
                    printf \"[${{executor}}] ERROR$ - ${{rc}} command not available!\"
                    fail=true
                fi
            done
            [[ \"${{fail}}\" == true ]] && exit 1

            # ------------------------------------------------------------------------------

            function get_host_port_reachable {{
                local -r REMOTE_HOST=$1
                local -r REMOTE_HOST_PORT=$2

                if nc -zv ${{REMOTE_HOST}} ${{REMOTE_HOST_PORT}} 2>&1 | grep -q 'Connected' ; then
                    echo 'true'
                else
                    echo 'false'
                fi
            }}

            host_reachable_address=none
            stored_address=none

            if [[ -f /var/lib/{systemd_name}.env ]]; then
                stored_address=\"$( head -n 1 /var/lib/{systemd_name}.env | cut -d '=' -f 2 )\"
                echo -e \"[${{executor}}] Found /var/lib/{systemd_name}.env with remote host adress @ ${{stored_address}}\"
            fi

            for addr in {server_addresses_oneliner}; do
                if [[ \"$( get_host_port_reachable ${{addr}} 445 )\" == true && \"$( get_host_port_reachable ${{addr}} 139 )\" == true ]]; then
                    echo -e \"[${{executor}}] Host found reachable @ ${{addr}}\"
                    host_reachable_address=\"${{addr}}\"
                    break
                fi
            done

            if [[ \"${{host_reachable_address}}\" == none ]]; then
                echo -e \"[${{executor}}] {share_name} not reachable - disabling share {share_name} mounted @ {mountpoint}...\"
                [[ \"$(systemctl is-active {systemd_name}.automount)\" == active ]] && systemctl stop {systemd_name}.automount
                [[ \"$(systemctl is-active {systemd_name}.mount)\" == active ]] && systemctl stop {systemd_name}.mount
                [[ -f /var/lib/{systemd_name}.env ]] && rm -v /var/lib/{systemd_name}.env

            else
                if [[ \"${{host_reachable_address}}\" != \"${{stored_address}}\" ]]; then
                    echo -e \"ADDRESS=${{host_reachable_address}}\" | tee /var/lib/{systemd_name}.env > /dev/null
                fi

                if [[ \"$(systemctl is-active {systemd_name}.automount)\" == inactive ]]; then
                    echo -e \"[${{executor}}] Attaching {share_name} @ {mountpoint} @ ${{host_reachable_address}}...\"
                    systemctl start {systemd_name}.automount
                elif [[ \"${{host_reachable_address}}\" != \"${{stored_address}}\" ]]; then
                    echo -e \"[${{executor}}] Remote host address change from ${{stored_address}} to ${{host_reachable_address}}\"
                    [[ \"$(systemctl is-active {systemd_name}.mount)\" == active ]] && systemctl try-restart {systemd_name}.mount
                    [[ \"$(systemctl is-active {systemd_name}.automount)\" == active ]] && systemctl try-restart {systemd_name}.automount
                fi
            fi

            # randomize sleep in case of multiple shares so they don't all hit at once
            # sleep \"$( shuf -i 5-15 -n 1 )s\"
        """
    )

    # ExecStart=/bin/bash -c '{" ".join([line.strip() for line in service_script.splitlines()])}'
    service = inspect.cleandoc(
        f"""\
            [Unit]
            Description=Check {server_name} is reachable and enable/disable mounts accordigly
            After=network-online.target
            Wants=network-online.target

            [Service]
            Type=oneshot
            LogNamespace={systemd_name}
            StandardOutput=journal+console
            ExecStart=/bin/bash {execstart_script_direcrory}/{systemd_name}.sh
        """
    )

    timer = inspect.cleandoc(
        f"""\
            [Unit]
            Description=Run {systemd_name}.service periodically
            After=network-online.target
            Wants=network-online.target

            [Timer]
            OnBootSec={random.randrange(1, 10)}s
            OnUnitInactiveSec={random.randrange(10, 20)}s

            [Install]
            WantedBy=timers.target
        """
    )

    mount = inspect.cleandoc(
        f"""\
            [Unit]
            Description={share_name} on {server_name} mount
            ConditionPathExists = /var/lib/{systemd_name}.env

            [Mount]
            EnvironmentFile=/var/lib/{systemd_name}.env
            What=//${{ADDRESS}}/{share_name}
            Where={mountpoint}
            Type=cifs
            # iocharset=utf8,vers=3.1.1
            Options=credentials={creds_file},uid={user_uid},gid={user_gid},file_mode=0700,dir_mode=0700,nofail,rw,exec,_netdev,soft
            TimeoutSec=10s

            [Install]
            WantedBy=multi-user.target
        """
    )

    automount = inspect.cleandoc(
        f"""\
            [Unit]
            Description={share_name} on {server_name} automount
            ConditionPathExists = {mountpoint}

            [Automount]
            Where={mountpoint}
            TimeoutIdleSec=30s

            [Install]
            WantedBy=multi-user.target
        """
    )

    log_namespace = inspect.cleandoc(
        f"""\
            [Journal]
            #Storage=auto
            #Compress=yes
            #Seal=yes
            #SplitMode=uid
            #SyncIntervalSec=5m
            #RateLimitIntervalSec=30s
            #RateLimitBurst=10000
            SystemMaxUse=50M
            #SystemKeepFree=
            #SystemMaxFileSize=
            SystemMaxFiles=1
            #RuntimeMaxUse=
            #RuntimeKeepFree=
            #RuntimeMaxFileSize=
            #RuntimeMaxFiles=100
            #MaxRetentionSec=
            #MaxFileSec=1month
            #ForwardToSyslog=yes
            #ForwardToKMsg=no
            #ForwardToConsole=no
            #ForwardToWall=yes
            #TTYPath=/dev/console
            #MaxLevelStore=debug
            #MaxLevelSyslog=debug
            #MaxLevelKMsg=notice
            #MaxLevelConsole=info
            #MaxLevelWall=emerg
            #LineMax=48K
            #ReadKMsg=yes
            #Audit=no
        """
    )

    creds = inspect.cleandoc(
        f"""\
            username={share_username}
            password={share_password}
            domain={share_domain}
        """
    )

    registry = inspect.cleandoc(
        f"""\
            {{
            "credentials_direcrory": "{credentials_direcrory}",
            "execstart_script_direcrory": "{execstart_script_direcrory}",
            "server_name": "{server_name}",
            "share_name": "{share_name}",
            "share_mount_under": "{share_mount_under}"
            }}
        """
    )

    if simulate:
        print(f"{'-' * os.get_terminal_size().columns}")
        print(f"{ptc.Yellow}Service:{ptc.Color_Off}")
        print(f"{'-' * os.get_terminal_size().columns}")
        print(f"{service}")

        print(f"{'-' * os.get_terminal_size().columns}")
        print(f"{ptc.Yellow}Script::{ptc.Color_Off}")
        print(f"{'-' * os.get_terminal_size().columns}")
        print(f"{service_script}")
        print(f"{'~' * os.get_terminal_size().columns}")
        print(f"echo '{service_script}'")
        print(f"{'~' * os.get_terminal_size().columns}")
        exec_cmd(f"echo '{service_script}'")

        print(f"{'-' * os.get_terminal_size().columns}")
        print(f"{ptc.Yellow}Timer:{ptc.Color_Off}")
        print(f"{'-' * os.get_terminal_size().columns}")
        print(f"{timer}")

        print(f"{'-' * os.get_terminal_size().columns}")
        print(f"{ptc.Yellow}Mount:{ptc.Color_Off}")
        print(f"{'-' * os.get_terminal_size().columns}")
        print(f"{mount}")

        print(f"{'-' * os.get_terminal_size().columns}")
        print(f"{ptc.Yellow}Automount:{ptc.Color_Off}")
        print(f"{'-' * os.get_terminal_size().columns}")
        print(f"{automount}")

        print(f"{'-' * os.get_terminal_size().columns}")
        print(f"{ptc.Yellow}journald conf:{ptc.Color_Off}")
        print(f"{'-' * os.get_terminal_size().columns}")
        print(f"{log_namespace}")

        print(f"{'-' * os.get_terminal_size().columns}")
        print(f"{ptc.Yellow}Creds:{ptc.Color_Off}")
        print(f"{'-' * os.get_terminal_size().columns}")
        print(f"{creds}")

        print(f"{ptc.Blue}[INFO]{ptc.Color_Off} Simulation complete!")
    else:

        print(f"{ptc.Blue}[INFO]{ptc.Color_Off} Generating files & enabling...")

        if not os.path.isdir(f"{mountpoint}"):
            if exec_cmd(f"mkdir -p '{mountpoint}'", fail_action="exit"):
                print(f"{ptc.Blue}[INFO]{ptc.Color_Off} Created '{mountpoint}'")
        else:
            print(f"{ptc.Blue}[INFO]{ptc.Color_Off} '{mountpoint}' already exists...")

        if not os.path.isdir(f"{creds_dir}"):
            if exec_cmd(f"mkdir -p '{creds_dir}'", fail_action="exit"):
                print(f"{ptc.Blue}[INFO]{ptc.Color_Off} Created '{creds_dir}'")
        else:
            print(f"{ptc.Blue}[INFO]{ptc.Color_Off} '{creds_dir}' already exists...")

        if exec_cmd(
            f"echo '{creds}' | tee '{creds_file}' > /dev/null", fail_action="exit"
        ) and exec_cmd(f"chmod 600 '{creds_file}'", fail_action="exit"):
            print(f"{ptc.Blue}[INFO]{ptc.Color_Off} Created {creds_file} ")

        with tempfile.NamedTemporaryFile(prefix=f"rfs__{systemd_name}__") as fp:
            with open(f"{fp.name}", "w") as f:
                for line in service_script.splitlines():
                    line = line + "\n"
                    f.write(line)

            if exec_cmd(
                f'sudo cp -f "{fp.name}" "{execstart_script_direcrory}/{systemd_name}.sh"',
                fail_action="exit",
            ) and exec_cmd(
                f"sudo chmod 700 {execstart_script_direcrory}/{systemd_name}.sh",
                fail_action="exit",
            ):
                print(
                    f"{ptc.Blue}[INFO]{ptc.Color_Off} Created {execstart_script_direcrory}/{systemd_name}.sh"
                )

        if exec_cmd(
            f"echo '{service}' | sudo tee /etc/systemd/system/{systemd_name}.service > /dev/null",
            fail_action="exit",
        ):
            print(
                f"{ptc.Blue}[INFO]{ptc.Color_Off} Created /etc/systemd/system/{systemd_name}.service"
            )

        if exec_cmd(
            f"echo '{timer}' | sudo tee /etc/systemd/system/{systemd_name}.timer > /dev/null",
            fail_action="exit",
        ):
            print(
                f"{ptc.Blue}[INFO]{ptc.Color_Off} Created /etc/systemd/system/{systemd_name}.timer"
            )

        if exec_cmd(
            f"echo '{mount}' | sudo tee /etc/systemd/system/{systemd_name}.mount > /dev/null",
            fail_action="exit",
        ):
            print(
                f"{ptc.Blue}[INFO]{ptc.Color_Off} Created /etc/systemd/system/{systemd_name}.mount"
            )

        if exec_cmd(
            f"echo '{automount}' | sudo tee /etc/systemd/system/{systemd_name}.automount > /dev/null",
            fail_action="exit",
        ):
            print(
                f"{ptc.Blue}[INFO]{ptc.Color_Off} Created /etc/systemd/system/{systemd_name}.automount"
            )

        if exec_cmd(
            f"echo '{log_namespace}' | sudo tee /etc/systemd/journald@{systemd_name}.conf > /dev/null",
            fail_action="exit",
        ):
            print(
                f"{ptc.Blue}[INFO]{ptc.Color_Off} Created /etc/systemd/journald@{systemd_name}.conf"
            )

        if exec_cmd(
            f"sudo systemctl daemon-reload && sudo systemctl enable --now {systemd_name}.timer && sudo systemctl start {systemd_name}.service",
            fail_action="exit",
        ):
            print(f"{ptc.Blue}[INFO]{ptc.Color_Off} Enabled systemd timer")

        # Generate rfs registry file
        if exec_cmd(
            f"echo '{registry}' | sudo tee /var/lib/{systemd_name}.rfs > /dev/null",
            fail_action="exit",
        ):
            print(
                f"{ptc.Blue}[INFO]{ptc.Color_Off} Created /var/lib/{systemd_name}.rfs"
            )

        print(f"{ptc.Blue}[INFO]{ptc.Color_Off} Done!")


def main():

    try:
        print(f"\n{ptc.BBlack}{ptc.On_White} [RFS] {ptc.Color_Off}\n")

        check_progs_installed("nc", fail_action="exit")

        parser = argparse.ArgumentParser(
            description="Create systemd service files for CIFS/SMB mounts defined in TOML format.",
            formatter_class=argparse.RawDescriptionHelpFormatter,
        )

        parser.add_argument(
            "-r",
            "--remove",
            action="store_true",
            help="Instead of adding rfs entries as read from user provided TOML file(s) which is the default behaviour, remove them if present.",
        )

        parser.add_argument(
            "-c",
            "--credentials_direcrory",
            default="~/.config/rfs",
            help="Directory to hold credentials files. Always use same ",
        )

        parser.add_argument(
            "-e",
            "--execstart_script_direcrory",
            default="/usr/local/bin",
            help="Directory to put service script. Default path is accessible to both immutable & normal Fedora as well as allowed by SELinux. Change this at your peril.",
        )

        parser.add_argument(
            "-s",
            "--simulate",
            action="store_true",
            help="Go through the motions but don't actually generate anything.",
        )

        parser.add_argument(
            "paths",
            metavar="P",
            type=str,
            nargs="*",  # n: n values, can be any number you want
            # ?: a single value, which can be optional
            # *: a flexible number of values, which will be gathered into a list
            # +: like *, but requiring at least one value
            # argparse.REMAINDER: all the values that are remaining in the command line
            help="Paths to YAML files.",
        )

        args = parser.parse_args()

        user_uid = getpwnam(f"{getpass.getuser()}").pw_uid  # Returns UID only
        user_gid = getgrnam(f"{getpass.getuser()}").gr_gid  # Returns GID only

        if len(args.paths) == 0:
            if args.remove:
                options = list(
                    f"/{str(pathlib.Path(f"{opt}").expanduser().resolve().stem).replace(
                        "-", "/"
                    )}"
                    for opt in glob.glob("/var/lib/*.rfs")
                )

                selection = f"/var/lib/{select_from_list("Pick a rfs entry", options).replace("/", "-").replace("-", "", 1)}.rfs"

                with open(selection, "r") as jsonfile:
                    data = json.load(jsonfile)

                    delete_rfs_files(
                        str(data["credentials_direcrory"]),
                        str(data["execstart_script_direcrory"]),
                        str(data["server_name"]),
                        str(data["share_name"]),
                        str(data["share_mount_under"]),
                    )
            else:
                server_name = input("share_server_name? ")
                server_addresses = [
                    sa.strip()
                    for sa in input(
                        "share_server_addresses separated by spaces? "
                    ).split(" ")
                ]
                while True:
                    share_name = input("share_name? ")
                    share_mount_under = input("share_mount_under? ")

                    share_username = input("share_username? ")
                    share_password = getpass.getpass("share_password? ")
                    share_domain = input("share_domain? ")
                    generate_rfs_files(
                        user_uid,
                        user_gid,
                        args.credentials_direcrory,
                        args.execstart_script_direcrory,
                        server_name,
                        server_addresses,
                        share_name,
                        share_mount_under,
                        share_username,
                        share_password,
                        share_domain,
                        args.simulate,
                    )
                    if input(
                        "Are there more shares on this server you wish to add? [(Y)es/(n)o]"
                    ).lower() in ["n", "no"]:
                        break

        else:
            input_file_index = 0
            for input_file in args.paths:
                input_file_index += 1

                print("#" * os.get_terminal_size().columns)
                print(
                    f"{ptc.Blue}[INFO]{ptc.Color_Off} [{input_file_index}/{len(args.paths)}] {str(input_file)}"
                )

                input_file = pathlib.Path(f"{input_file}").expanduser().resolve()

                if not input_file.is_file():
                    print(
                        f"{ptc.Red}[ERROR]{ptc.Color_Off} Does not exist or not a file!"
                    )
                else:
                    with open(input_file, mode="rb") as toml_file:
                        toml_data = tomllib.load(toml_file)

                    for server in toml_data["servers"]:
                        print("=" * os.get_terminal_size().columns)
                        print(
                            f"{ptc.Blue}[INFO]{ptc.Color_Off} Server {server["name"]} @ {'|'.join(server["addresses"])}"
                        )

                        if len(server["shares"]) == 0:
                            print(f"{ptc.Red}[ERROR]{ptc.Color_Off} No shares defined!")
                        else:

                            share_index = 0
                            shares_number = len(server["shares"])
                            for share in server["shares"]:
                                share_index += 1

                                print("-" * os.get_terminal_size().columns)
                                print(
                                    f"{ptc.Blue}[INFO]{ptc.Color_Off} Share [{share_index}/{shares_number}] {share["name"]}\n"
                                )

                                if args.remove:
                                    delete_rfs_files(
                                        args.credentials_direcrory,
                                        args.execstart_script_direcrory,
                                        server["name"],
                                        share["name"],
                                        share["mount_under"],
                                    )
                                else:
                                    generate_rfs_files(
                                        user_uid,
                                        user_gid,
                                        args.credentials_direcrory,
                                        args.execstart_script_direcrory,
                                        server["name"],
                                        server["addresses"],
                                        share["name"],
                                        share["mount_under"],
                                        share["username"],
                                        share["password"],
                                        share["domain"],
                                        args.simulate,
                                    )

    except KeyboardInterrupt:
        print(
            f"\n\n{ptc.BBlack}{ptc.On_White} KeyboardInterrupt detected. Cleaning up and exiting... {ptc.Color_Off}"
        )
        sys.exit(0)  # Exit gracefully with exit status 0


if __name__ == "__main__":

    # tests = [
    #     ["valid_fqdn", "homestarrunner.net", True],
    #     ["valid_fqdn", "zombo.lan.com", True],
    #     ["valid_fqdn", "zombo-host.lan.com", True],
    #     ["valid_fqdn", "zombo-host2.lan.com", True],
    #     ["valid_fqdn", "foo", True],
    #     ["valid_fqdn", "", False],
    #     ["valid_fqdn", " ", False],
    #     ["valid_fqdn", "a*", False],
    #     ["valid_ip", "192.168.1.200", True],
    #     ["valid_ip", "1.1.1.2", True],
    #     ["valid_ip", "0.0.0.0", True],
    #     ["valid_ip", "66.55.44.33", True],
    #     ["valid_ip", "", False],
    #     ["valid_ip", "a*", False],
    #     ["valid_ip", "foo", False],
    #     ["valid_ip", "foo.net", False],
    #     ["valid_ip", "660.55.44.33", False],
    #     ["valid_ip", "66.550.44.33", False],
    #     ["valid_ip", "66.55.440.33", False],
    #     ["valid_ip", "66.55.44.330", False],
    #     ["valid_ip", "66.55..33", False],
    #     ["valid_ip", "66.55.33.", False],
    #     ["valid_ip", "66.55.33", False],
    #     ["valid_ip", ".66.55.33", False],
    #     ["valid_ip", "1::", True],
    #     ["valid_ip", "1:2:3:4:5:6:7::", True],
    #     ["valid_ip", "1::8", True],
    #     ["valid_ip", "1:2:3:4:5:6::8", True],
    #     ["valid_ip", "1:2:3:4:5:6::8", True],
    #     ["valid_ip", "1::7:8", True],
    #     ["valid_ip", "1:2:3:4:5::7:8", True],
    #     ["valid_ip", "1:2:3:4:5::8", True],
    #     ["valid_ip", "1::6:7:8", True],
    #     ["valid_ip", "1:2:3:4::6:7:8", True],
    #     ["valid_ip", "1:2:3:4::8", True],
    #     ["valid_ip", "1::5:6:7:8", True],
    #     ["valid_ip", "1:2:3::5:6:7:8", True],
    #     ["valid_ip", "1:2:3::8", True],
    #     ["valid_ip", "1::4:5:6:7:8", True],
    #     ["valid_ip", "1:2::4:5:6:7:8", True],
    #     ["valid_ip", "1:2::8", True],
    #     ["valid_ip", "1::3:4:5:6:7:8", True],
    #     ["valid_ip", "1::3:4:5:6:7:8", True],
    #     ["valid_ip", "1::8", True],
    #     ["valid_ip", "::2:3:4:5:6:7:8", True],
    #     ["valid_ip", "::2:3:4:5:6:7:8", True],
    #     ["valid_ip", "::8", True],
    #     ["valid_ip", "::", True],
    #     ["valid_ip", "fe80::7:8%eth0", True],
    #     ["valid_ip", "fe80::7:8%1", True],
    #     ["valid_ip", "::255.255.255.255", True],
    #     ["valid_ip", "::ffff:255.255.255.255", True],
    #     ["valid_ip", "::ffff:0:255.255.255.255", True],
    #     ["valid_ip", "2001:db8:3:4::192.0.2.33", True],
    #     ["valid_ip", "64:ff9b::192.0.2.33", True],
    #     ["valid_ip", "0:0:0:0:0:0:10.0.0.1", True],
    #     ["valid_ip", "::FFFF:129.144.52.38", True],
    # ]

    # unit_tests(tests)

    main()
